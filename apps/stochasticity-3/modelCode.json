{"status":"success","errors":null,"data":{"valid":true,"metadata":{"variables":["I","S","I_det","extinct"],"parameters":[{"name":"beta","default":0.5,"min":null,"max":null,"is_integer":false,"rank":0},{"name":"I_init","default":1,"min":null,"max":null,"is_integer":false,"rank":0},{"name":"initialise_at_steady_state","default":1,"min":0,"max":1,"is_integer":false,"rank":0},{"name":"N","default":1000,"min":null,"max":null,"is_integer":false,"rank":0},{"name":"sigma","default":0.3,"min":null,"max":null,"is_integer":false,"rank":0}],"dt":0.01,"messages":[]},"model":"\"use strict\";\nclass odin {\n  constructor(base, user, unusedUserAction) {\n    this.base = base;\n    this.internal = {};\n    var internal = this.internal;\n    internal.dt = 0.01;\n    this.setUser(user, unusedUserAction);\n  }\n  initial(step) {\n    var internal = this.internal;\n    var state = Array(4).fill(0);\n    state[0] = internal.initial_I;\n    state[1] = internal.initial_S;\n    state[2] = internal.initial_I_det;\n    state[3] = internal.initial_extinct;\n    return state;\n  }\n  setUser(user, unusedUserAction) {\n    this.base.user.checkUser(user, [\"beta\", \"I_init\", \"initialise_at_steady_state\", \"N\", \"sigma\"], unusedUserAction);\n    var internal = this.internal;\n    this.base.user.setUserScalar(user, \"beta\", internal, 0.5, -Infinity, Infinity, false);\n    this.base.user.setUserScalar(user, \"I_init\", internal, 1, -Infinity, Infinity, false);\n    this.base.user.setUserScalar(user, \"initialise_at_steady_state\", internal, 1, 0, 1, true);\n    this.base.user.setUserScalar(user, \"N\", internal, 1000, -Infinity, Infinity, false);\n    this.base.user.setUserScalar(user, \"sigma\", internal, 0.29999999999999999, -Infinity, Infinity, false);\n    internal.I_star = (internal.beta > internal.sigma ? internal.N * (internal.beta - internal.sigma) / internal.beta : 0);\n    internal.initial_I = (internal.initialise_at_steady_state == 1 ? this.base.maths.round2(internal.I_star) : internal.I_init);\n    internal.initial_extinct = internal.initial_I == 0;\n    internal.initial_I_det = internal.initial_I;\n    internal.initial_S = internal.N - internal.initial_I;\n  }\n  getInternal() {\n    return this.internal;\n  }\n  update(step, state, state_next, random) {\n    var internal = this.internal;\n    const S = state[1];\n    const I = state[0];\n    var FOI = internal.beta * I / internal.N;\n    var n_recoveries = random.binomial(this.base.maths.round2(I), internal.sigma * internal.dt);\n    var time = step * internal.dt;\n    state_next[3] = I == 0;\n    state_next[1] = internal.N - I;\n    var n_infections = random.binomial(this.base.maths.round2(S), FOI * internal.dt);\n    state_next[2] = (internal.initialise_at_steady_state ? internal.I_star : (internal.I_star / (1 + (internal.I_star / internal.I_init - 1) * Math.exp(- (internal.beta - internal.sigma) * time))));\n    state_next[0] = I + n_infections - n_recoveries;\n  }\n  info() {\n    const ret = [];\n    const internal = this.internal;\n    ret.push({ dim: [], length: 1, name: \"I\"});\n    ret.push({ dim: [], length: 1, name: \"S\"});\n    ret.push({ dim: [], length: 1, name: \"I_det\"});\n    ret.push({ dim: [], length: 1, name: \"extinct\"});\n    return ret;\n  }\n  size() {\n    const internal = this.internal;\n    return 4;\n  }\n}\nodin;"}}