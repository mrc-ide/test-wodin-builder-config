{"status":"success","errors":null,"data":{"valid":true,"metadata":{"variables":["S","I","R","extinct"],"parameters":[{"name":"beta","default":0.5,"min":null,"max":null,"is_integer":false,"rank":0},{"name":"I_init","default":5,"min":null,"max":null,"is_integer":false,"rank":0},{"name":"initialise_at_steady_state","default":0,"min":0,"max":1,"is_integer":false,"rank":0},{"name":"mu","default":0.0004,"min":null,"max":null,"is_integer":false,"rank":0},{"name":"N","default":10000,"min":null,"max":null,"is_integer":false,"rank":0},{"name":"prop_immune","default":0,"min":null,"max":null,"is_integer":false,"rank":0},{"name":"sigma","default":0.3,"min":null,"max":null,"is_integer":false,"rank":0}],"dt":0.01,"messages":[]},"model":"\"use strict\";\nclass odin {\n  constructor(base, user, unusedUserAction) {\n    this.base = base;\n    this.internal = {};\n    var internal = this.internal;\n    internal.dt = 0.01;\n    this.setUser(user, unusedUserAction);\n  }\n  initial(step) {\n    var internal = this.internal;\n    var state = Array(4).fill(0);\n    state[0] = internal.initial_S;\n    state[1] = internal.initial_I;\n    state[2] = internal.initial_R;\n    state[3] = internal.initial_extinct;\n    return state;\n  }\n  setUser(user, unusedUserAction) {\n    this.base.user.checkUser(user, [\"beta\", \"I_init\", \"initialise_at_steady_state\", \"mu\", \"N\", \"prop_immune\", \"sigma\"], unusedUserAction);\n    var internal = this.internal;\n    this.base.user.setUserScalar(user, \"beta\", internal, 0.5, -Infinity, Infinity, false);\n    this.base.user.setUserScalar(user, \"I_init\", internal, 5, -Infinity, Infinity, false);\n    this.base.user.setUserScalar(user, \"initialise_at_steady_state\", internal, 0, 0, 1, true);\n    this.base.user.setUserScalar(user, \"mu\", internal, 0.00038000000000000002, -Infinity, Infinity, false);\n    this.base.user.setUserScalar(user, \"N\", internal, 10000, -Infinity, Infinity, false);\n    this.base.user.setUserScalar(user, \"prop_immune\", internal, 0, -Infinity, Infinity, false);\n    this.base.user.setUserScalar(user, \"sigma\", internal, 0.29999999999999999, -Infinity, Infinity, false);\n    internal.I_star = internal.N * internal.mu * (internal.beta - internal.sigma - internal.mu) / (internal.beta * (internal.mu + internal.sigma));\n    internal.R0 = internal.beta / (internal.sigma + internal.mu);\n    internal.S_init = (internal.N - internal.I_init) * (1 - internal.prop_immune);\n    internal.initial_I = (internal.initialise_at_steady_state == 1 ? this.base.maths.round2(internal.I_star) : internal.I_init);\n    internal.S_star = internal.N / internal.R0;\n    internal.initial_extinct = internal.initial_I == 0;\n    internal.initial_R = (internal.initialise_at_steady_state == 1 ? internal.N - this.base.maths.round2(internal.I_star) - this.base.maths.round2(internal.S_star) : internal.N - internal.I_init - internal.S_init);\n    internal.initial_S = (internal.initialise_at_steady_state == 1 ? this.base.maths.round2(internal.S_star) : internal.S_init);\n  }\n  getInternal() {\n    return this.internal;\n  }\n  update(step, state, state_next, random) {\n    var internal = this.internal;\n    const S = state[0];\n    const I = state[1];\n    const R = state[2];\n    var FOI = internal.beta * I / internal.N;\n    var n_deaths_R = random.binomial(this.base.maths.round2(R), internal.mu * internal.dt);\n    var n_events_I = random.binomial(this.base.maths.round2(I), (internal.sigma + internal.mu) * internal.dt);\n    state_next[3] = I == 0;\n    var n_deaths_I = random.binomial(this.base.maths.round2(n_events_I), internal.mu / (internal.mu + internal.sigma));\n    var n_events_S = random.binomial(this.base.maths.round2(S), (FOI + internal.mu) * internal.dt);\n    var n_deaths_S = random.binomial(this.base.maths.round2(n_events_S), internal.mu / (FOI + internal.mu));\n    var n_recoveries_I = n_events_I - n_deaths_I;\n    var n_births = n_deaths_S + n_deaths_I + n_deaths_R;\n    var n_infections_S = n_events_S - n_deaths_S;\n    state_next[2] = R + n_recoveries_I - n_deaths_R;\n    state_next[1] = I + n_infections_S - n_recoveries_I - n_deaths_I;\n    state_next[0] = S - n_deaths_S - n_infections_S + n_births;\n  }\n  info() {\n    const ret = [];\n    const internal = this.internal;\n    ret.push({ dim: [], length: 1, name: \"S\"});\n    ret.push({ dim: [], length: 1, name: \"I\"});\n    ret.push({ dim: [], length: 1, name: \"R\"});\n    ret.push({ dim: [], length: 1, name: \"extinct\"});\n    return ret;\n  }\n  size() {\n    const internal = this.internal;\n    return 4;\n  }\n}\nodin;"}}